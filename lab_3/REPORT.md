# Asymmetric Ciphers

### Course: Cryptography & Security
### Author: Boicu Stefan

----

## Objectives:

* Learn the theory and principles of asymetric ciphers
* Implement an asymetric encryption algorithm. I implemented RSA

### Key settings

First, install the golang language on your system. [Link for download](https://go.dev/learn/)

This laboratory work also has test coverage. Tests prove that the cipher work as intended. To verify that all the tests run correctly run.

`$go test ./pkg/ -v`

# RSA

## Theory

RSA uses the properties of modular arhitmetic to securely encrypt data. The two main properties are that prime factorisation is a very slow task when the numbers are big enough, and that modular arhitmetics allows 

## Implementation

The RSA cipher is very simple at its core. Encryption and decryption proceeding in the same way, except for the key used. In encryption we use the public key and for decryption we use the private key.

To perform encryption I simply raise the block of plaintext to the power of the secret number modulo *n*. I chose to perform encryption over an array of bytes to avoid overflow errors when encrypting strings.

```go
func RSAEncryption(plaintext []int64, rsaKey Key) []int64 {
	ciphertext := make([]int64, len(plaintext))
	for i, block := range plaintext {
		cipherBlock := moduloPow(int64(block), rsaKey.ed, rsaKey.n)
		ciphertext[i] = cipherBlock
	}
	return ciphertext
}
```

The keys are generated by using two (preferably large) prime numbers.

```go
func generateKeyPair(primeA, primeB int64) (privateKey Key, publicKey Key) {
	n := primeA * primeB
	phi := (primeA - 1) * (primeB - 1)
	e := FindCoprime(phi)
	var x, y int64
	Exgcd(e, phi, &x, &y)
	d := (x + phi) % phi

	publicKey = Key{e, n}
	privateKey = Key{d, n}

	return privateKey, publicKey
}
```

To find the smallest coprime number fo the public key I simply use the euclidean algorithm to check if the greatest common divisor is equal to 1.

```go
func Gcd(a, b int64) int64 {
	for {
		temp := a % b
		if temp == 0 {
			return b
		}
		a = b
		b = temp
	}
}
```

```go
func FindCoprime(phi int64) int64 {
	for i := int64(3); i < phi; i++ {
		if Gcd(i, phi) == 1 {
			return i
		}
	}
	return phi - 1
}
```

For the private key I use the extended euclidean algorithm to find the modulo inverse of e mod n.

```go
func Exgcd(a, b int64, x, y *int64) int64 {
	// base case
	if b == 0 {
		*x = 1
		*y = 0
		return a
	}

	var x1 int64 = 1
	var y1 int64 = 1
	d := Exgcd(b, a%b, &x1, &y1)
	*x = y1
	*y = x1 - y1*(a/b)
	return d
}
```

I implemented a modulo power function to avoid overflow.

```go
func moduloPow(a, b, mod int64) int64 {
	var result int64 = 1
	for i := int64(0); i < b; i++ {
		result = (result * a) % mod
	}
	return result
}
```

## Conclusions

As part of this laboratory work I learned about asymetric encryption algorithm and how to implement them.